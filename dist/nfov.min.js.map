{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///nfov.min.js","webpack:///webpack/bootstrap b0c50782d42987a5119a","webpack:///./src/handlers/basic.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","handler","nfov","agents","targets","callback","each","_agent","agent","_target","target","targetInRange","targetInFOV","targetIsVisible","objs","Array","isArray","forEach","obj","fixPrecision","number","precision","Math","round","parseAngle","angle","isDegrees","isClockwise","PI","basicObject","x","position","Error","y","body","width","height","anchor","origin","agentObj","distance","getDistance","direction","maxAngle","getAngle","RADIANS","getAngleUnit","DEGREES","getOrientation","CLOCKWISE","rotation","angleDiff","angle1","angle2","halfCircle","fullCircle","diff","makeRay","tileSize","delta","abs","over","floor","current","step","point","next","dx","dy","sqrt","angle2Target","atan2","grid","getGrid","getTileSize","acceptableTiles","getAcceptableTiles","rayCast","tile","indexOf","config","assign","angleUnit","orientation","COUNTERCLOCKWISE","basicHandler","setDistance","setAngle","setAngleUnit","setOrientation","setGrid","setTileSize","setAcceptableTiles","setHandler","unit","widthOrObj","tiles","slice","getHandler","detect"],"mappings":"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","file":"nfov.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nfov\"] = factory();\n\telse\n\t\troot[\"nfov\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nfov\"] = factory();\n\telse\n\t\troot[\"nfov\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar handler = function handler(nfov, agents, targets, callback) {\n  handler.each(agents, function eachAgent(_agent) {\n    var agent = handler.agent(nfov, _agent);\n\n    handler.each(targets, function eachTarget(_target) {\n      var target = handler.target(nfov, _target);\n\n      if (handler.targetInRange(nfov, agent, target) && handler.targetInFOV(nfov, agent, target) && handler.targetIsVisible(nfov, agent, target)) {\n        callback(_agent, _target);\n      }\n    });\n  });\n};\n\nhandler.each = function each(objs, callback) {\n  if (Array.isArray(objs)) {\n    objs.forEach(function (obj) {\n      handler.each(obj, callback);\n    });\n  } else {\n    callback(objs);\n  }\n};\n\nhandler.fixPrecision = function fixPrecision(number) {\n  var precision = 10000000000;\n  return Math.round(number * precision) / precision;\n};\n\nhandler.parseAngle = function parseAngle(angle, isDegrees, isClockwise) {\n  angle = isDegrees === true ? angle * Math.PI / 180 : angle;\n  angle = angle >= 0 ? angle : angle + Math.PI * 2;\n  angle = isClockwise === true && angle > 0 ? Math.PI * 2 - angle : angle;\n  return angle;\n};\n\nhandler.basicObject = function basicObject(nfov, obj) {\n  if (obj.x == null && obj.position == null) {\n    throw new Error('Object position not found');\n  }\n\n  var position = {\n    x: obj.x,\n    y: obj.y\n  };\n\n  var body = {\n    width: obj.width,\n    height: obj.height\n  };\n\n  var anchor = {\n    x: 0.5,\n    y: 0.5\n  };\n\n  // phaser | pixi\n  if (obj.position != null) {\n    position.x = obj.position.x;\n    position.y = obj.position.y;\n  }\n\n  // phaser\n  if (obj.body != null && obj.body.width != null) {\n    body.width = obj.body.width;\n    body.height = obj.body.height;\n  }\n\n  // phaser | pixi\n  if (obj.anchor != null) {\n    anchor.x = 0;\n    anchor.y = 0;\n  }\n\n  return {\n    origin: {\n      x: position.x + body.width * anchor.x,\n      y: position.y + body.height * anchor.y\n    }\n  };\n};\n\nhandler.agent = function agent(nfov, obj) {\n  var agentObj = handler.basicObject(nfov, obj);\n\n  agentObj.distance = nfov.getDistance();\n  agentObj.direction = 0;\n  agentObj.maxAngle = nfov.getAngle(nfov.RADIANS);\n\n  if (obj.distance != null) {\n    agentObj.distance = obj.distance;\n  }\n\n  if (obj.direction != null) {\n    agentObj.direction = handler.parseAngle(obj.direction, nfov.getAngleUnit() === nfov.DEGREES, nfov.getOrientation() === nfov.CLOCKWISE);\n  } else if (obj.body != null && obj.body.rotation != null) {\n    // phaser\n    agentObj.direction = handler.parseAngle(obj.body.rotation, true, true);\n  } else if (obj.body != null && obj.body.angle != null) {\n    // phaser\n    agentObj.direction = handler.parseAngle(obj.body.angle, false, true);\n  } else if (obj.rotation != null) {\n    agentObj.direction = handler.parseAngle(obj.rotation, nfov.getAngleUnit() === nfov.DEGREES, nfov.getOrientation() === nfov.CLOCKWISE);\n  }\n\n  if (obj.maxAngle != null) {\n    agentObj.maxAngle = nfov.getAngleUnit() === nfov.DEGREES ? obj.maxAngle * Math.PI / 180 : obj.maxAngle;\n  }\n\n  return agentObj;\n};\n\nhandler.target = function target(nfov, obj) {\n  return handler.basicObject(nfov, obj);\n};\n\nhandler.angleDiff = function angleDiff(angle1, angle2) {\n  var halfCircle = Math.PI;\n  var fullCircle = halfCircle * 2;\n\n  var diff = angle1 - angle2;\n  diff = diff % fullCircle;\n\n  if (diff >= halfCircle) {\n    diff -= fullCircle;\n  } else if (diff < -halfCircle) {\n    diff += fullCircle;\n  }\n\n  return diff;\n};\n\nhandler.makeRay = function makeRay(_agent, _target, tileSize) {\n  var agent = {\n    x: _agent.x / tileSize.width,\n    y: _agent.y / tileSize.height\n  };\n\n  var target = {\n    x: _target.x / tileSize.width,\n    y: _target.y / tileSize.height\n  };\n\n  var direction = {\n    x: target.x - agent.x,\n    y: target.y - agent.y\n  };\n\n  var delta = {\n    x: direction.x === 0 ? 0 : Math.abs(1 / direction.x),\n    y: direction.y === 0 ? 0 : Math.abs(1 / direction.y)\n  };\n\n  var over = {\n    x: agent.x - Math.floor(agent.x),\n    y: agent.y - Math.floor(agent.y)\n  };\n\n  var current = {\n    x: direction.x === 0 ? 2 : (direction.x > 0 ? 1 - over.x : over.x) * delta.x,\n    y: direction.y === 0 ? 2 : (direction.y > 0 ? 1 - over.y : over.y) * delta.y\n  };\n\n  var step = {\n    x: direction.x >= 0 ? 1 : -1,\n    y: direction.y >= 0 ? 1 : -1\n  };\n\n  var point = {\n    x: Math.floor(agent.x),\n    y: Math.floor(agent.y)\n  };\n\n  return {\n    next: function next() {\n      if (current.x > 1 && current.y > 1) {\n        return false;\n      }\n\n      if (current.x <= current.y) {\n        current.x += delta.x;\n        point.x += step.x;\n      } else {\n        current.y += delta.y;\n        point.y += step.y;\n      }\n\n      return {\n        x: point.x,\n        y: point.y\n      };\n    }\n  };\n};\n\nhandler.targetInRange = function targetInRange(nfov, agent, target) {\n  if (agent.distance > 0) {\n    var dx = target.origin.x - agent.origin.x;\n    var dy = agent.origin.y - target.origin.y;\n    var distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= agent.distance;\n  } else {\n    return true;\n  }\n};\n\nhandler.targetInFOV = function targetInFOV(nfov, agent, target) {\n  var halfCircle = Math.PI;\n  var fullCircle = halfCircle * 2;\n\n  if (agent.maxAngle > 0 && agent.maxAngle < fullCircle) {\n    var angle2Target = Math.atan2(agent.origin.y - target.origin.y, target.origin.x - agent.origin.x);\n    var diff = handler.fixPrecision(handler.angleDiff(agent.direction, angle2Target));\n    var maxAngle = handler.fixPrecision(agent.maxAngle / 2);\n    return diff <= maxAngle && diff >= -maxAngle;\n  } else {\n    return true;\n  }\n};\n\nhandler.targetIsVisible = function targetIsVisible(nfov, agent, target) {\n  var grid = nfov.getGrid();\n\n  if (grid != null) {\n    var tileSize = nfov.getTileSize();\n    var acceptableTiles = nfov.getAcceptableTiles();\n\n    var rayCast = handler.makeRay(agent.origin, target.origin, tileSize);\n    var point = rayCast.next();\n\n    while (point) {\n      if (grid[point.y] != null && grid[point.y][point.x] != null) {\n        var tile = grid[point.y][point.x];\n\n        if (acceptableTiles.indexOf(tile) >= 0) {\n          point = rayCast.next();\n        } else {\n          return false;\n        }\n      } else {\n        // tile not mapped\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = handler;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar basicHandler = __webpack_require__(0);\n\nfunction nfov(config) {\n  if (!(this instanceof nfov)) {\n    throw new Error('Constructor called as a function');\n  }\n\n  config = Object.assign({\n    distance: 0,\n    angle: 0,\n    angleUnit: nfov.RADIANS,\n    orientation: nfov.COUNTERCLOCKWISE,\n    grid: null,\n    tileSize: {\n      width: 1,\n      height: 1\n    },\n    acceptableTiles: [],\n    handler: basicHandler\n  }, config);\n\n  this.setDistance(config.distance);\n  this.setAngle(config.angle);\n  this.setAngleUnit(config.angleUnit);\n  this.setOrientation(config.orientation);\n  this.setGrid(config.grid);\n  this.setTileSize(config.tileSize);\n  this.setAcceptableTiles(config.acceptableTiles);\n  this.setHandler(config.handler);\n}\n\nnfov.RADIANS = nfov.prototype.RADIANS = 1;\nnfov.DEGREES = nfov.prototype.DEGREES = 2;\n\nnfov.CLOCKWISE = nfov.prototype.CLOCKWISE = 1;\nnfov.COUNTERCLOCKWISE = nfov.prototype.COUNTERCLOCKWISE = 2;\n\nnfov.prototype.setDistance = function setDistance(distance) {\n  if (typeof distance === 'number' && distance >= 0) {\n    this.distance = distance;\n  } else {\n    throw new Error('Invalid value passed for `distance`');\n  }\n};\n\nnfov.prototype.getDistance = function getDistance() {\n  return this.distance;\n};\n\nnfov.prototype.setAngle = function setAngle(angle) {\n  if (typeof angle === 'number' && angle >= 0) {\n    this.angle = angle;\n  } else {\n    throw new Error('Invalid value passed for `angle`');\n  }\n};\n\nnfov.prototype.getAngle = function getAngle(unit) {\n  if (unit === nfov.RADIANS) {\n    if (this.getAngleUnit() === nfov.DEGREES) {\n      return this.angle * Math.PI / 180;\n    }\n  } else if (unit === nfov.DEGREES) {\n    if (this.getAngleUnit() === nfov.RADIANS) {\n      return this.angle * 180 / Math.PI;\n    }\n  }\n\n  return this.angle;\n};\n\nnfov.prototype.setAngleUnit = function setAngleUnit(angleUnit) {\n  if (angleUnit === nfov.RADIANS) {\n    this.angleUnit = nfov.RADIANS;\n  } else if (angleUnit === nfov.DEGREES) {\n    this.angleUnit = nfov.DEGREES;\n  } else {\n    throw new Error('Invalid value passed for `angleUnit`');\n  }\n};\n\nnfov.prototype.getAngleUnit = function getAngleUnit() {\n  return this.angleUnit;\n};\n\nnfov.prototype.setOrientation = function setOrientation(orientation) {\n  if (orientation === nfov.CLOCKWISE) {\n    this.orientation = nfov.CLOCKWISE;\n  } else if (orientation === nfov.COUNTERCLOCKWISE) {\n    this.orientation = nfov.COUNTERCLOCKWISE;\n  } else {\n    throw new Error('Invalid value passed for `orientation`');\n  }\n};\n\nnfov.prototype.getOrientation = function getOrientation() {\n  return this.orientation;\n};\n\nnfov.prototype.setGrid = function setGrid(grid) {\n  if (grid == null || Array.isArray(grid)) {\n    this.grid = grid;\n  } else {\n    throw new Error('Invalid value passed for `grid`');\n  }\n};\n\nnfov.prototype.getGrid = function getGrid() {\n  return this.grid;\n};\n\nnfov.prototype.setTileSize = function setTileSize(widthOrObj, height) {\n  if (widthOrObj > 0) {\n    this.tileSize = {\n      width: widthOrObj,\n      height: height > 0 ? height : widthOrObj\n    };\n  } else if (widthOrObj != null && widthOrObj.width > 0 && widthOrObj.height > 0) {\n    this.tileSize = {\n      width: widthOrObj.width,\n      height: widthOrObj.height\n    };\n  } else {\n    throw new Error('Invalid value passed for `tileSize`');\n  }\n};\n\nnfov.prototype.getTileSize = function getTileSize() {\n  return this.tileSize;\n};\n\nnfov.prototype.setAcceptableTiles = function setAcceptableTiles(tiles) {\n  if (Array.isArray(tiles)) {\n    this.acceptableTiles = tiles.slice(0);\n  } else if (tiles != null) {\n    this.acceptableTiles = [tiles];\n  } else {\n    throw new Error('Invalid value passed for `tiles`');\n  }\n};\n\nnfov.prototype.getAcceptableTiles = function getAcceptableTiles() {\n  return this.acceptableTiles;\n};\n\nnfov.prototype.setHandler = function setHandler(handler) {\n  if (typeof handler === 'function') {\n    this.handler = handler;\n  } else {\n    throw new Error('Invalid value passed for `handler`');\n  }\n};\n\nnfov.prototype.getHandler = function getHandler() {\n  return this.handler;\n};\n\nnfov.prototype.detect = function detect(agents, targets, callback) {\n  var handler = this.getHandler();\n  handler(this, agents, targets, callback);\n};\n\nmodule.exports = nfov;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// nfov.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b0c50782d42987a5119a","const handler = function handler (nfov, agents, targets, callback) {\r\n  handler.each(agents, function eachAgent (_agent) {\r\n    const agent = handler.agent(nfov, _agent)\r\n\r\n    handler.each(targets, function eachTarget (_target) {\r\n      const target = handler.target(nfov, _target)\r\n\r\n      if (handler.targetInRange(nfov, agent, target) &&\r\n          handler.targetInFOV(nfov, agent, target) &&\r\n          handler.targetIsVisible(nfov, agent, target)) {\r\n        callback(_agent, _target)\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nhandler.each = function each (objs, callback) {\r\n  if (Array.isArray(objs)) {\r\n    objs.forEach(function (obj) {\r\n      handler.each(obj, callback)\r\n    })\r\n  } else {\r\n    callback(objs)\r\n  }\r\n}\r\n\r\nhandler.fixPrecision = function fixPrecision (number) {\r\n  const precision = 10000000000\r\n  return Math.round(number * precision) / precision\r\n}\r\n\r\nhandler.parseAngle = function parseAngle (angle, isDegrees, isClockwise) {\r\n  angle = isDegrees === true ? angle * Math.PI / 180 : angle\r\n  angle = angle >= 0 ? angle : angle + Math.PI * 2\r\n  angle = isClockwise === true && angle > 0 ? Math.PI * 2 - angle : angle\r\n  return angle\r\n}\r\n\r\nhandler.basicObject = function basicObject (nfov, obj) {\r\n  if (obj.x == null && obj.position == null) {\r\n    throw new Error('Object position not found')\r\n  }\r\n\r\n  const position = {\r\n    x: obj.x,\r\n    y: obj.y\r\n  }\r\n\r\n  const body = {\r\n    width: obj.width,\r\n    height: obj.height\r\n  }\r\n\r\n  const anchor = {\r\n    x: 0.5,\r\n    y: 0.5\r\n  }\r\n\r\n  // phaser | pixi\r\n  if (obj.position != null) {\r\n    position.x = obj.position.x\r\n    position.y = obj.position.y\r\n  }\r\n\r\n  // phaser\r\n  if (obj.body != null && obj.body.width != null) {\r\n    body.width = obj.body.width\r\n    body.height = obj.body.height\r\n  }\r\n\r\n  // phaser | pixi\r\n  if (obj.anchor != null) {\r\n    anchor.x = 0\r\n    anchor.y = 0\r\n  }\r\n\r\n  return {\r\n    origin: {\r\n      x: position.x + body.width * anchor.x,\r\n      y: position.y + body.height * anchor.y\r\n    }\r\n  }\r\n}\r\n\r\nhandler.agent = function agent (nfov, obj) {\r\n  const agentObj = handler.basicObject(nfov, obj)\r\n\r\n  agentObj.distance = nfov.getDistance()\r\n  agentObj.direction = 0\r\n  agentObj.maxAngle = nfov.getAngle(nfov.RADIANS)\r\n\r\n  if (obj.distance != null) {\r\n    agentObj.distance = obj.distance\r\n  }\r\n\r\n  if (obj.direction != null) {\r\n    agentObj.direction = handler.parseAngle(obj.direction, nfov.getAngleUnit() === nfov.DEGREES, nfov.getOrientation() === nfov.CLOCKWISE)\r\n  } else if (obj.body != null && obj.body.rotation != null) {\r\n    // phaser\r\n    agentObj.direction = handler.parseAngle(obj.body.rotation, true, true)\r\n  } else if (obj.body != null && obj.body.angle != null) {\r\n    // phaser\r\n    agentObj.direction = handler.parseAngle(obj.body.angle, false, true)\r\n  } else if (obj.rotation != null) {\r\n    agentObj.direction = handler.parseAngle(obj.rotation, nfov.getAngleUnit() === nfov.DEGREES, nfov.getOrientation() === nfov.CLOCKWISE)\r\n  }\r\n\r\n  if (obj.maxAngle != null) {\r\n    agentObj.maxAngle = nfov.getAngleUnit() === nfov.DEGREES ? obj.maxAngle * Math.PI / 180 : obj.maxAngle\r\n  }\r\n\r\n  return agentObj\r\n}\r\n\r\nhandler.target = function target (nfov, obj) {\r\n  return handler.basicObject(nfov, obj)\r\n}\r\n\r\nhandler.angleDiff = function angleDiff (angle1, angle2) {\r\n  const halfCircle = Math.PI\r\n  const fullCircle = halfCircle * 2\r\n\r\n  let diff = angle1 - angle2\r\n  diff = diff % fullCircle\r\n\r\n  if (diff >= halfCircle) {\r\n    diff -= fullCircle\r\n  } else if (diff < -halfCircle) {\r\n    diff += fullCircle\r\n  }\r\n\r\n  return diff\r\n}\r\n\r\nhandler.makeRay = function makeRay (_agent, _target, tileSize) {\r\n  const agent = {\r\n    x: _agent.x / tileSize.width,\r\n    y: _agent.y / tileSize.height\r\n  }\r\n\r\n  const target = {\r\n    x: _target.x / tileSize.width,\r\n    y: _target.y / tileSize.height\r\n  }\r\n\r\n  const direction = {\r\n    x: target.x - agent.x,\r\n    y: target.y - agent.y\r\n  }\r\n\r\n  const delta = {\r\n    x: direction.x === 0 ? 0 : Math.abs(1 / direction.x),\r\n    y: direction.y === 0 ? 0 : Math.abs(1 / direction.y)\r\n  }\r\n\r\n  const over = {\r\n    x: agent.x - Math.floor(agent.x),\r\n    y: agent.y - Math.floor(agent.y)\r\n  }\r\n\r\n  const current = {\r\n    x: direction.x === 0 ? 2 : (direction.x > 0 ? 1 - over.x : over.x) * delta.x,\r\n    y: direction.y === 0 ? 2 : (direction.y > 0 ? 1 - over.y : over.y) * delta.y\r\n  }\r\n\r\n  const step = {\r\n    x: direction.x >= 0 ? 1 : -1,\r\n    y: direction.y >= 0 ? 1 : -1\r\n  }\r\n\r\n  const point = {\r\n    x: Math.floor(agent.x),\r\n    y: Math.floor(agent.y)\r\n  }\r\n\r\n  return {\r\n    next: function next () {\r\n      if (current.x > 1 && current.y > 1) {\r\n        return false\r\n      }\r\n\r\n      if (current.x <= current.y) {\r\n        current.x += delta.x\r\n        point.x += step.x\r\n      } else {\r\n        current.y += delta.y\r\n        point.y += step.y\r\n      }\r\n\r\n      return {\r\n        x: point.x,\r\n        y: point.y\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nhandler.targetInRange = function targetInRange (nfov, agent, target) {\r\n  if (agent.distance > 0) {\r\n    const dx = target.origin.x - agent.origin.x\r\n    const dy = agent.origin.y - target.origin.y\r\n    const distance = Math.sqrt(dx * dx + dy * dy)\r\n    return distance <= agent.distance\r\n  } else {\r\n    return true\r\n  }\r\n}\r\n\r\nhandler.targetInFOV = function targetInFOV (nfov, agent, target) {\r\n  const halfCircle = Math.PI\r\n  const fullCircle = halfCircle * 2\r\n\r\n  if (agent.maxAngle > 0 && agent.maxAngle < fullCircle) {\r\n    const angle2Target = Math.atan2(agent.origin.y - target.origin.y, target.origin.x - agent.origin.x)\r\n    const diff = handler.fixPrecision(handler.angleDiff(agent.direction, angle2Target))\r\n    const maxAngle = handler.fixPrecision(agent.maxAngle / 2)\r\n    return diff <= maxAngle && diff >= -maxAngle\r\n  } else {\r\n    return true\r\n  }\r\n}\r\n\r\nhandler.targetIsVisible = function targetIsVisible (nfov, agent, target) {\r\n  const grid = nfov.getGrid()\r\n\r\n  if (grid != null) {\r\n    const tileSize = nfov.getTileSize()\r\n    const acceptableTiles = nfov.getAcceptableTiles()\r\n\r\n    const rayCast = handler.makeRay(agent.origin, target.origin, tileSize)\r\n    let point = rayCast.next()\r\n\r\n    while (point) {\r\n      if (grid[point.y] != null && grid[point.y][point.x] != null) {\r\n        const tile = grid[point.y][point.x]\r\n\r\n        if (acceptableTiles.indexOf(tile) >= 0) {\r\n          point = rayCast.next()\r\n        } else {\r\n          return false\r\n        }\r\n      } else {\r\n        // tile not mapped\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nmodule.exports = handler\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/handlers/basic.js","const basicHandler = require('./handlers/basic')\r\n\r\nfunction nfov (config) {\r\n  if (!(this instanceof nfov)) {\r\n    throw new Error('Constructor called as a function')\r\n  }\r\n\r\n  config = Object.assign({\r\n    distance: 0,\r\n    angle: 0,\r\n    angleUnit: nfov.RADIANS,\r\n    orientation: nfov.COUNTERCLOCKWISE,\r\n    grid: null,\r\n    tileSize: {\r\n      width: 1,\r\n      height: 1\r\n    },\r\n    acceptableTiles: [],\r\n    handler: basicHandler\r\n  }, config)\r\n\r\n  this.setDistance(config.distance)\r\n  this.setAngle(config.angle)\r\n  this.setAngleUnit(config.angleUnit)\r\n  this.setOrientation(config.orientation)\r\n  this.setGrid(config.grid)\r\n  this.setTileSize(config.tileSize)\r\n  this.setAcceptableTiles(config.acceptableTiles)\r\n  this.setHandler(config.handler)\r\n}\r\n\r\nnfov.RADIANS = nfov.prototype.RADIANS = 1\r\nnfov.DEGREES = nfov.prototype.DEGREES = 2\r\n\r\nnfov.CLOCKWISE = nfov.prototype.CLOCKWISE = 1\r\nnfov.COUNTERCLOCKWISE = nfov.prototype.COUNTERCLOCKWISE = 2\r\n\r\nnfov.prototype.setDistance = function setDistance (distance) {\r\n  if (typeof distance === 'number' && distance >= 0) {\r\n    this.distance = distance\r\n  } else {\r\n    throw new Error('Invalid value passed for `distance`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getDistance = function getDistance () {\r\n  return this.distance\r\n}\r\n\r\nnfov.prototype.setAngle = function setAngle (angle) {\r\n  if (typeof angle === 'number' && angle >= 0) {\r\n    this.angle = angle\r\n  } else {\r\n    throw new Error('Invalid value passed for `angle`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getAngle = function getAngle (unit) {\r\n  if (unit === nfov.RADIANS) {\r\n    if (this.getAngleUnit() === nfov.DEGREES) {\r\n      return this.angle * Math.PI / 180\r\n    }\r\n  } else if (unit === nfov.DEGREES) {\r\n    if (this.getAngleUnit() === nfov.RADIANS) {\r\n      return this.angle * 180 / Math.PI\r\n    }\r\n  }\r\n\r\n  return this.angle\r\n}\r\n\r\nnfov.prototype.setAngleUnit = function setAngleUnit (angleUnit) {\r\n  if (angleUnit === nfov.RADIANS) {\r\n    this.angleUnit = nfov.RADIANS\r\n  } else if (angleUnit === nfov.DEGREES) {\r\n    this.angleUnit = nfov.DEGREES\r\n  } else {\r\n    throw new Error('Invalid value passed for `angleUnit`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getAngleUnit = function getAngleUnit () {\r\n  return this.angleUnit\r\n}\r\n\r\nnfov.prototype.setOrientation = function setOrientation (orientation) {\r\n  if (orientation === nfov.CLOCKWISE) {\r\n    this.orientation = nfov.CLOCKWISE\r\n  } else if (orientation === nfov.COUNTERCLOCKWISE) {\r\n    this.orientation = nfov.COUNTERCLOCKWISE\r\n  } else {\r\n    throw new Error('Invalid value passed for `orientation`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getOrientation = function getOrientation () {\r\n  return this.orientation\r\n}\r\n\r\nnfov.prototype.setGrid = function setGrid (grid) {\r\n  if (grid == null || Array.isArray(grid)) {\r\n    this.grid = grid\r\n  } else {\r\n    throw new Error('Invalid value passed for `grid`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getGrid = function getGrid () {\r\n  return this.grid\r\n}\r\n\r\nnfov.prototype.setTileSize = function setTileSize (widthOrObj, height) {\r\n  if (widthOrObj > 0) {\r\n    this.tileSize = {\r\n      width: widthOrObj,\r\n      height: height > 0 ? height : widthOrObj\r\n    }\r\n  } else if (widthOrObj != null && widthOrObj.width > 0 && widthOrObj.height > 0) {\r\n    this.tileSize = {\r\n      width: widthOrObj.width,\r\n      height: widthOrObj.height\r\n    }\r\n  } else {\r\n    throw new Error('Invalid value passed for `tileSize`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getTileSize = function getTileSize () {\r\n  return this.tileSize\r\n}\r\n\r\nnfov.prototype.setAcceptableTiles = function setAcceptableTiles (tiles) {\r\n  if (Array.isArray(tiles)) {\r\n    this.acceptableTiles = tiles.slice(0)\r\n  } else if (tiles != null) {\r\n    this.acceptableTiles = [tiles]\r\n  } else {\r\n    throw new Error('Invalid value passed for `tiles`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getAcceptableTiles = function getAcceptableTiles () {\r\n  return this.acceptableTiles\r\n}\r\n\r\nnfov.prototype.setHandler = function setHandler (handler) {\r\n  if (typeof handler === 'function') {\r\n    this.handler = handler\r\n  } else {\r\n    throw new Error('Invalid value passed for `handler`')\r\n  }\r\n}\r\n\r\nnfov.prototype.getHandler = function getHandler () {\r\n  return this.handler\r\n}\r\n\r\nnfov.prototype.detect = function detect (agents, targets, callback) {\r\n  const handler = this.getHandler()\r\n  handler(this, agents, targets, callback)\r\n}\r\n\r\nmodule.exports = nfov\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}